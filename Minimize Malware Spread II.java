import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

public class Solution 
{   
    public static int bfs(ArrayList<ArrayList<Integer>> graph, HashSet<Integer> infectedNodes, int cur)
    {
        // Create a queue.
        Queue<Integer> q = new LinkedList<>();
        
        // Push all initially infected nodes.
        for (Integer v : infectedNodes)
        {
            q.add(v);
        }

        // Find all infected nodes after the malware spread.
        while (!q.isEmpty())
        {
            int v = q.peek();
            q.poll();

            // Run though all the direct connections of 'v'.
            for (int i = 0; i < graph.get(v).size(); i++)
            {   
                int x = graph.get(v).get(i);
                if (i != cur && x == 1 && infectedNodes.contains(i) == false)
                {
                    // If this true, then mark this node to be infected.
                    // Push this node into the queue, and insert it into the HashSet.
                    q.add(i);
                    infectedNodes.add(i);
                }
            }
        }

        // HashSet contain all infected nodes after removal of cur, so return size of HashSet.
        return infectedNodes.size();
    }

    public static int minMalwareSpread(ArrayList<ArrayList<Integer>>  graph, ArrayList<Integer>  initial) 
    {    
	    // Create a HashSet that contains all initially infected nodes.
        HashSet<Integer>infectedNodes = new HashSet<>();
        HashSet<Integer> temp = new HashSet<>();
        for(int i=0 ; i<initial.size() ; i++)
        {
            infectedNodes.add(initial.get(i));
            temp.add(initial.get(i));
        }
        
        
        // Declare variables.
        int ans = 0;
        int minCount = Integer.MAX_VALUE;

        // Run through vector initial.
        for (Integer cur : initial)
        {   
            // Remove current node.
            infectedNodes.remove(cur);
                    
            // Call the bfs to calculate total infected nodes after the malware spread.
            int cnt = bfs(graph, infectedNodes, cur);
            infectedNodes = (HashSet)temp.clone();
            // Update ans.
            if (cnt < minCount || (cnt == minCount && cur < ans))
            {
                minCount = cnt;
                ans = cur;
            }
         
            // Insert current node.
            infectedNodes.add(cur);
            
        }

        return ans;
	}
}
